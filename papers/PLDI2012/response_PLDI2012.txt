Reviewer #1
"the title is fairly vague and non optimal -- perhaps
"succinct" should be replaced by "disjunctive"?"
Path focusing and our combined technique (with or without disjunctive invariants) do not work on the classical control flow graph, but on a multigraph where all the paths inside loops are distinguished.
"Succinct" refers to the fact we actually do not represent explicitly all these paths, but instead list them on demand as solutions to an SMT formula; see Papadimitriou "succinct representations of graphs" using SAT formulas.

"The results are unsurprising"
The experimental results show that techniques that distinguish paths inside a
program give more precise results, but, more importantly, at a reasonable cost
(non-obvious).
Interestingly, more precise techniques (e.g. guided static analysis) perform sometimes faster that more naive approaches.

Reviewer #2
"The problem with guided static analysis is [...] thus losing precision"
Precisely, the precision loss is due to "least upper bound" operators at intermediate control joins, which may add spurious states.

"The problem with path focusing is that [...] analysis."
This is not exactly the point. The problem with path focusing is that it will compute the fixpoint iterations on the whole graph at once, using classical widening operations in order to guarantee the convergence. When a fixpoint has been reached, it finally applies some narrowing iterations to recover precision.
Guided static analysis instead applies narrowing iterations at intermediate point during the analysis, in order to recover some precision, not only at the end of the ascending iterations.

"how much benefit this technique confers to other types of abstract
domains, including those that don't require widening"
Intuitively, guided static analysis performs better because it
recovers precision lost by widening. It will probably not increase the precision
when using domains without widening/narrowing.
However, since the iteration strategy is changed, the computation time may differ compared to a classical abstract interpretation. The same applies to our combined technique compared to Path Focusing.

"I'd like to know more about how applicable the technique is to other kinds of abstract domains"
The general idea does not depend on the abstract domain. However, we have to
transform an abstract value into an SMT formula. Such transformation is easy in
our case, since a polyhedron in constraint form is a conjunction of linear inequalities, but further work may be needed for efficient encoding of e.g. alias and pointer information (these can be encoded as uninterpreted functions with functional updates, aka arrays, but solving the resulting formulas may be costly).

Reviewer #3
"2 to 5% difference, does it make a difference at all?"
Our prototype of analyzer performs many over-approximations, especially since it has no memory model: the program is preprocessed by a LLVM memory-to-scalar pass, and all memory references that this pass cannot turn into SSA variables are considered undefined. This often results in very imprecise invariants regardless of the iteration method and domain used.

We thus expect that a less rough treatment of memory will yield more marked differences between iteration techniques.
